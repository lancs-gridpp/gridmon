#!/bin/env python3

## Copyright (c) 2022, Lancaster University
## All rights reserved.
##
## Redistribution and use in source and binary forms, with or without
## modification, are permitted provided that the following conditions
## are met:
##
## 1. Redistributions of source code must retain the above copyright
##    notice, this list of conditions and the following disclaimer.
##
## 2. Redistributions in binary form must reproduce the above
##    copyright notice, this list of conditions and the following
##    disclaimer in the documentation and/or other materials provided
##    with the distribution.
##
## 3. Neither the name of the copyright holder nor the names of its
##    contributors may be used to endorse or promote products derived
##    from this software without specific prior written permission.
##
## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
## "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
## LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
## FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
## COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
## SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
## HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
## STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
## OF THE POSSIBILITY OF SUCH DAMAGE.

import time
import urllib.request
import yaml
import ssl
import sys
from http.server import BaseHTTPRequestHandler, HTTPServer


## From somewhere...?
class hashabledict(dict):
    def __key(self):
        return tuple((k,self[k]) for k in sorted(self))
    def __hash__(self):
        return hash(self.__key())
    def __eq__(self, other):
        return self.__key() == other.__key()

ctx = ssl.create_default_context()
ctx.check_hostname = False
ctx.verify_mode = ssl.CERT_NONE

endpoint = "https://xxxx/esmond/perfsonar/archive/"

result = { }
lastTime = int(time.time())
resetTime = lastTime

class MyServer(BaseHTTPRequestHandler):
    def do_GET(self):
        ## Get all the data since the last query.
        currTime = int(time.time())
        global result
        global endpoint
        global lastTime
        global ctx
        url = endpoint + ("?time-start=%d&time-end=%d" %
                          (lastTime + 1, currTime))
        req = urllib.request.urlopen(url, context=ctx)
        doc = yaml.load(req, Loader=yaml.SafeLoader)

        ## Merge the latest data with our records.
        for elem in doc:
            if elem['source'] == elem['measurement-agent']:
                agent = 'source'
            else:
                agent = 'destination'
                pass
            duration = float(elem.get("time-duration"))
            k = hashabledict({ "source": elem.get("input-source"),
                               "tool": elem.get("tool-name"),
                               "destination": elem.get("input-destination"),
                               "agent" : agent })
            entry = result.get(k)
            if entry is None:
                entry = { "count" : 0, "duration": 0.0 }
                result[k] = entry
                pass
            entry['count'] += 1
            entry['duration'] += duration
            pass
        lastTime = currTime

        ## Write out the new data.
        self.send_response(200)
        self.send_header("Content-Type", "text/plain; charset=UTF-8")
        self.end_headers()
        out = self.wfile
        out.write(bytes("# HELP perfsonar_task_duration_seconds" +
                        " duration of tasks\n", "UTF-8"))
        out.write(bytes("# TYPE perfsonar_task_duration_seconds" +
                        " counter\n", "UTF-8"))
        for k in result:
            v = result[k]
            out.write(bytes(('perfsonar_task_duration_seconds_count{' +
                             'source="%s", destination="%s",' +
                             ' agent="%s", tool="%s"} %g\n') %
                            (k['source'], k['destination'], k['agent'],
                             k['tool'], v['count']), "UTF-8"))
            out.write(bytes(('perfsonar_task_duration_seconds_sum{source="%s",' +
                             ' destination="%s", agent="%s", tool="%s"} %g\n') %
                            (k['source'], k['destination'], k['agent'],
                             k['tool'], v['duration']), "UTF-8"))
            out.write(bytes(('perfsonar_task_duration_seconds_created{' +
                             'source="%s", destination="%s",' +
                             ' agent="%s", tool="%s"} %f\n') %
                            (k['source'], k['destination'], k['agent'],
                             k['tool'], resetTime), "UTF-8"))
        pass

    pass

hostName = "localhost"
serverPort = 8732

if __name__ == "__main__":
    webServer = HTTPServer((hostName, serverPort), MyServer)
    print("Started on http://%s:%s" % (hostName, serverPort))

    try:
        webServer.serve_forever()
    except KeyboardInterrupt:
        pass

    webServer.server_close()
    print("Server stopped.")
    pass
