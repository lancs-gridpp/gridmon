#!/bin/env python3

## Copyright (c) 2022, Lancaster University
## All rights reserved.
##
## Redistribution and use in source and binary forms, with or without
## modification, are permitted provided that the following conditions
## are met:
##
## 1. Redistributions of source code must retain the above copyright
##    notice, this list of conditions and the following disclaimer.
##
## 2. Redistributions in binary form must reproduce the above
##    copyright notice, this list of conditions and the following
##    disclaimer in the documentation and/or other materials provided
##    with the distribution.
##
## 3. Neither the name of the copyright holder nor the names of its
##    contributors may be used to endorse or promote products derived
##    from this software without specific prior written permission.
##
## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
## "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
## LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
## FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
## COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
## SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
## HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
## STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
## OF THE POSSIBILITY OF SUCH DAMAGE.

import traceback
import time
import threading
from pprint import pprint
import socket
from defusedxml import ElementTree
from http.server import BaseHTTPRequestHandler, HTTPServer
import functools
import xml
import sys

#erk = ElementTree.fromstring('<stats id="oss" v="2"><paths>1<stats id="0"><lp>"/cephfs"</lp><rp>"/cephfs"</rp><tot>10966251003904</tot><free>10041593004032</free><ino>306797597</ino><ifr>-1</ifr></stats></paths><space>0</space></stats>')
#print('Got [%s]' % erk.find('paths/stats[@id="0"]'))
#sys.exit()

class XRootDHistory:
    def __init__(self, horizon=60*30):
        self.entries = { }
        self.lock = threading.Lock()
        self.horizon = horizon
        self.running = True
        pass

    def install(self, ts, inst, data):
        with self.lock:
            threshold = int(time.time()) - self.horizon
            self.entries.setdefault(ts, {})[inst] = data
            for k in [ k for k in self.entries if k < threshold ]:
                del self.entries[k]
                continue
            pprint(self.entries)
            pass
        pass

    def add_metric2(self, k, mtr, fmt, func, attrs):
        entry = self.entries.get(k)
        if entry is None:
            return ''
        msg = ''
        for inst in entry:
            try:
                data = entry[inst]
                value = func(data)
            except:
                continue
            labels = 'host="%s",name="%s"' % inst
            if attrs is not None:
                ## The key is the attribute name.  The value is a
                ## tuple (afmt, af).  afmt is a format specifier for
                ## the value.  af is a function to obtain the value
                ## from the data.
                for an in attrs:
                    atp = attrs[an]
                    af = atp[1]
                    afmt = atp[0]
                    av = af(data)
                    labels += (',%s="' + afmt + '"') % (an, av)
                    continue
                pass
            msg += mtr
            msg += '{'
            msg += labels
            msg += '}'
            msg += (' ' + fmt + ' %.3f\n') % (value, k)
            continue
        return msg

    def add_metric(self, k, mtr, fmt, func, attrs):
        entry = self.entries.get(k)
        if entry is None:
            return ''
        msg = ''
        for inst in entry:
            try:
                data = entry[inst]
                value = func(data)
            except:
                continue
            labels = 'host="%s",name="%s"' % inst
            if attrs is not None:
                ## The key is the attribute name.  The value is a
                ## tuple (afmt, af).  afmt is a format specifier for
                ## the value.  af is a function to obtain the value
                ## from the data.
                for an in attrs:
                    atp = attrs[an]
                    af = atp[1]
                    afmt = atp[0]
                    av = af(data)
                    labels += (',%s="' + afmt + '"') % (an, av)
                    continue
                pass
            msg += mtr
            msg += '{'
            msg += labels
            msg += '}'
            msg += (' ' + fmt + ' %.3f\n') % (value, k)
            continue
        return msg

    def select_metric(self, entry, sel, already):
        if len(sel) == 0:
            return { }
        res = { }
        for sf in sel:
            continue
        pass

    def add_metric_family(self, ks, sel, mtr, bits, hlp=None, unit=None,
                          typ=None, attrs=None):
        ## A metric with a unit should end with the unit.
        if unit is not None:
            mtr += '_' + unit
            pass

        ## For each timestamp in ks, build up a set of tuples (one per
        ## entry in sel)...
        tups_per_ts = { }
        for k in ks:
            entry = self.entries.get(k)
            if entry is None:
                continue

            for sf in sel:
                continue
            continue
        pass

    def add_metrics(self, ks, mtr, bits, hlp=None, unit=None,
                    typ=None, attrs=None):
        ## A metric with a unit should end with the unit.
        if unit is not None:
            mtr += '_' + unit
            pass

        ## Start the message with metadata,
        msg = ''
        if typ is not None:
            msg += '# TYPE %s %s\n' % (mtr, typ)
            pass
        if unit is not None:
            msg += '# UNIT %s %s\n' % (mtr, unit)
            pass
        if hlp is not None:
            ## TODO: Escape the message.
            msg += '# HELP %s %s\n' % (mtr, hlp)
            pass

        ## Identify instances with available data.
        insts = set()
        for k in ks:
            entry = self.entries.get(k)
            if entry is None:
                continue
            for inst in entry:
                data = entry[inst]
                for (sfx, fmt, func) in bits:
                    try:
                        value = func(data)
                    except:
                        continue
                    insts.add(inst)
                    break
                continue
            continue

        ## Indexed by instance, then timestamp, then bit, write out
        ## the metrics.
        for inst in insts:
            for k in ks:
                entry = self.entries.get(k)
                if entry is None:
                    continue
                for (sfx, fmt, func) in bits:
                    msg += self.add_metric(k, mtr + sfx, fmt, func, attrs)
                    continue
                continue
            continue

        return msg

    def get_message(self, ts):
        msg = ''

        with self.lock:
            ## Identify the most recent entries that the client has
            ## not yet seen.  These are sorted to ensure all metrics
            ## come out in the same order.
            ks = [ k for k in self.entries if k > ts ]
            ks.sort()

            ## Identify the latest time of all matching entries and
            ## the caller's timestamp.
            latest = ts if len(ks) == 0 else max(ts, ks[-1])
        
            ## Build up a message with any data that has arrived since
            ## ts.
            msg += self.add_metrics(ks, 'xrootd_buff_mem',
                                    bits=[
                                        ("", "%d",
                                         lambda data: data['buff']['mem'])
                                    ],
                                    typ='gauge', unit='bytes',
                                    hlp='bytes allocated to buffers')

            msg += self.add_metrics(ks, 'xrootd_buff_buffs',
                                    bits=[
                                        ("", "%d",
                                         lambda data: data['buff']['buffs'])
                                    ],
                                    typ='gauge',
                                    hlp='number of allocated buffers')

            msg += self.add_metrics(ks, 'xrootd_buff_adj',
                                    bits=[
                                        ("_total", "%d",
                                         lambda data: data['buff']['adj']),
                                        ('_created', "%d",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='number of buffer profile adjustments')

            msg += self.add_metrics(ks, 'xrootd_buff_reqs',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['buff']['reqs']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='number of buffer requests')

            msg += self.add_metrics(ks, 'xrootd_link_num',
                                    bits=[
                                        ("", "%d",
                                         lambda data: data['link']['num'])
                                    ],
                                    typ='gauge',
                                    hlp='number of current connections')

            msg += self.add_metrics(ks, 'xrootd_sgen_et',
                                    unit='seconds',
                                    bits=[
                                        ("", "%.6f",
                                         lambda data: data['sgen']['et'] / 1e6)
                                    ],
                                    typ='gauge',
                                    hlp='elapsed time for stats completion')

            msg += self.add_metrics(ks, 'xrootd_sgen_toe',
                                    unit='seconds',
                                    bits=[
                                        ("", "%d",
                                         lambda data: data['sgen']['toe'])
                                    ],
                                    typ='gauge',
                                    hlp='stats completion time')

            msg += self.add_metrics(ks, 'xrootd_sgen_as',
                                    bits=[
                                        ("", "%d",
                                         lambda data: data['sgen']['as'] / 1e6)
                                    ],
                                    typ='gauge',
                                    hlp='async stats')

            msg += self.add_metrics(ks, 'xrootd_link_ctime',
                                    unit='seconds',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['link']['ctime']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='cummulative time spent in connections')

            msg += self.add_metrics(ks, 'xrootd_link_maxn',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['link']['maxn']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='maximum number of concurrent connections')

            msg += self.add_metrics(ks, 'xrootd_link_tot',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['link']['tot']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='total number of connections')

            msg += self.add_metrics(ks, 'xrootd_link_tmo',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['link']['tmo']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='read request timeouts')

            msg += self.add_metrics(ks, 'xrootd_link_stall',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['link']['stall']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='partial data received occurrences')

            msg += self.add_metrics(ks, 'xrootd_link_sfps',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['link']['sfps']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='partial sendfile ops')

            msg += self.add_metrics(ks, 'xrootd_link_in',
                                    unit='bytes',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['link']['in']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='bytes received')

            msg += self.add_metrics(ks, 'xrootd_link_out',
                                    unit='bytes',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['link']['out']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='bytes transmitted')

            msg += self.add_metrics(ks, 'xrootd_sched_idle',
                                    bits=[
                                        ('', "%d",
                                         lambda data: data['sched']['idle'])
                                    ],
                                    typ='gauge',
                                    hlp='scheduler threads waiting for work')

            msg += self.add_metrics(ks, 'xrootd_sched_inq',
                                    bits=[
                                        ('', "%d",
                                         lambda data: data['sched']['inq'])
                                    ],
                                    typ='gauge',
                                    hlp='jobs in run queue')

            msg += self.add_metrics(ks, 'xrootd_sched_jobs',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['sched']['jobs']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='jobs requiring a thread')

            msg += self.add_metrics(ks, 'xrootd_sched_maxinq',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['sched']['maxinq']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='longest run-queue length')

            msg += self.add_metrics(ks, 'xrootd_sched_tcr',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['sched']['tcr']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='thread creations')

            msg += self.add_metrics(ks, 'xrootd_sched_tde',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['sched']['tde']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='thread destructions')

            msg += self.add_metrics(ks, 'xrootd_sched_threads',
                                    bits=[
                                        ('', "%d",
                                         lambda data: data['sched']['threads'])
                                    ],
                                    typ='gauge',
                                    hlp='current scheduler threads')

            msg += self.add_metrics(ks, 'xrootd_sched_tlimr',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['sched']['tlimr']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='thread limit attained occurrences')

            msg += self.add_metrics(ks, 'xrootd_poll_att',
                                    bits=[
                                        ('', "%d",
                                         lambda data: data['poll']['att'])
                                    ],
                                    typ='gauge',
                                    hlp='file descriptors attached for polling')

            msg += self.add_metrics(ks, 'xrootd_poll_en',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['poll']['en']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='poll enable ops')

            msg += self.add_metrics(ks, 'xrootd_poll_ev',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['poll']['ev']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='polling events')

            msg += self.add_metrics(ks, 'xrootd_poll_int',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['poll']['int']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='unsolicited polling events')

            msg += self.add_metrics(ks, 'xrootd_proc_sys',
                                    unit='seconds',
                                    bits=[
                                        ('_total', "%.6f",
                                         lambda data: data['proc']['sys']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='system time')

            msg += self.add_metrics(ks, 'xrootd_proc_usr',
                                    unit='seconds',
                                    bits=[
                                        ('_total', "%.6f",
                                         lambda data: data['proc']['usr']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='user time')

            msg += self.add_metrics(ks, 'xrootd_ofs_han',
                                    bits=[
                                        ('', "%d",
                                         lambda data: data['ofs']['han'])
                                    ],
                                    typ='gauge',
                                    hlp='active file handles')

            msg += self.add_metrics(ks, 'xrootd_ofs_opp',
                                    bits=[
                                        ('', "%d",
                                         lambda data: data['ofs']['opp'])
                                    ],
                                    typ='gauge',
                                    hlp='files open in read-write POSC mode')

            msg += self.add_metrics(ks, 'xrootd_ofs_opw',
                                    bits=[
                                        ('', "%d",
                                         lambda data: data['ofs']['opw'])
                                    ],
                                    typ='gauge',
                                    hlp='files open in read-write mode')

            msg += self.add_metrics(ks, 'xrootd_ofs_opr',
                                    bits=[
                                        ('', "%d",
                                         lambda data: data['ofs']['opr'])
                                    ],
                                    typ='gauge',
                                    hlp='files open in read mode')

            msg += self.add_metrics(ks, 'xrootd_ofs_meta',
                                    attrs={
                                        'role': ('%s', lambda data : data['ofs']['role'])
                                    },
                                    bits=[
                                        ('_info', "%d", lambda data: 1)
                                    ],
                                    typ='info',
                                    hlp='reporter metadata')

            msg += self.add_metrics(ks, 'xrootd_ofs_bxq',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['ofs']['bxq']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='background tasks processed')

            msg += self.add_metrics(ks, 'xrootd_ofs_dly',
                                    unit='seconds',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['ofs']['dly']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='delays imposed')

            msg += self.add_metrics(ks, 'xrootd_ofs_err',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['ofs']['err']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='errors encountered')

            msg += self.add_metrics(ks, 'xrootd_ofs_rdr',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['ofs']['rdr']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='redirects processed')

            msg += self.add_metrics(ks, 'xrootd_ofs_rep',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['ofs']['rep']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='background replies processed')

            msg += self.add_metrics(ks, 'xrootd_ofs_ser',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['ofs']['ser']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='received events indicating failure')

            msg += self.add_metrics(ks, 'xrootd_ofs_sok',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['ofs']['sok']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='received events indicating success')

            msg += self.add_metrics(ks, 'xrootd_ofs_ups',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['ofs']['ups']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='POSC-mode file unpersisted occurrences')

            msg += self.add_metrics(ks, 'xrootd_ofs_tpc_grnt',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['ofs']['tpc']['grnt']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='TPCs granted')

            msg += self.add_metrics(ks, 'xrootd_ofs_tpc_deny',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['ofs']['tpc']['deny']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='TPCs denied')

            msg += self.add_metrics(ks, 'xrootd_ofs_tpc_err',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['ofs']['tpc']['err']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='failed TPCs')

            msg += self.add_metrics(ks, 'xrootd_ofs_tpc_exp',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['ofs']['tpc']['exp']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='TPCs with expired auth')

            msg += self.add_metrics(ks, 'xrootd_xrootd_num',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['xrootd']['num']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='xrootd protocol selections')

            msg += self.add_metrics(ks, 'xrootd_xrootd_dly',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['xrootd']['dly']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='xrootd delayed requests')

            msg += self.add_metrics(ks, 'xrootd_xrootd_err',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['xrootd']['err']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='xrootd requests in error')

            msg += self.add_metrics(ks, 'xrootd_xrootd_rdr',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['xrootd']['rdr']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='xrootd redirections')

            msg += self.add_metrics(ks, 'xrootd_xrootd_aio_max',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['xrootd']['aio']['max']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='xrootd maximum simultaneous asynchronous requests')

            msg += self.add_metrics(ks, 'xrootd_xrootd_aio_num',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['xrootd']['aio']['num']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='xrootd asynchronous requests processed')

            msg += self.add_metrics(ks, 'xrootd_xrootd_aio_rej',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['xrootd']['aio']['rej']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='xrootd asynchronous requests converted to synchronous')

            msg += self.add_metrics(ks, 'xrootd_xrootd_ops_getf',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['xrootd']['ops']['getf']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='xrootd getfile requests')

            msg += self.add_metrics(ks, 'xrootd_xrootd_ops_misc',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['xrootd']['ops']['misc']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='xrootd other requests')

            msg += self.add_metrics(ks, 'xrootd_xrootd_ops_open',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['xrootd']['ops']['open']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='xrootd file-open requests')

            msg += self.add_metrics(ks, 'xrootd_xrootd_ops_pr',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['xrootd']['ops']['pr']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='xrootd pre-read requests')

            msg += self.add_metrics(ks, 'xrootd_xrootd_ops_putf',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['xrootd']['ops']['putf']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='xrootd putfile requests')

            msg += self.add_metrics(ks, 'xrootd_xrootd_ops_rf',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['xrootd']['ops']['rf']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='xrootd cache-refresh requests')

            msg += self.add_metrics(ks, 'xrootd_xrootd_ops_rd',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['xrootd']['ops']['rd']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='xrootd read requests')

            msg += self.add_metrics(ks, 'xrootd_xrootd_ops_rs',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['xrootd']['ops']['rs']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='xrootd readv segments')

            msg += self.add_metrics(ks, 'xrootd_xrootd_ops_rv',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['xrootd']['ops']['rv']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='xrootd readv requests')

            msg += self.add_metrics(ks, 'xrootd_xrootd_ops_sync',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['xrootd']['ops']['sync']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='xrootd sync requests')

            msg += self.add_metrics(ks, 'xrootd_xrootd_ops_wr',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['xrootd']['ops']['wr']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='xrootd write requests')

            msg += self.add_metrics(ks, 'xrootd_xrootd_lgn_num',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['xrootd']['lgn']['num']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='xrootd login attempts')

            msg += self.add_metrics(ks, 'xrootd_xrootd_lgn_af',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['xrootd']['lgn']['af']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='xrootd login failures')

            msg += self.add_metrics(ks, 'xrootd_xrootd_lgn_au',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['xrootd']['lgn']['au']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='xrootd login authentications')

            msg += self.add_metrics(ks, 'xrootd_xrootd_lgn_ua',
                                    bits=[
                                        ('_total', "%d",
                                         lambda data: data['xrootd']['lgn']['ua']),
                                        ('_created', "%.3f",
                                         lambda data: data['start'])
                                    ],
                                    typ='counter',
                                    hlp='xrootd unauthenticated logins')

            # msg += self.add_metrics(ks, 'xrootd_oss_paths_free',
            #                         unit='bytes',
            #                         attrs={
            #                             'real_path': ('%s', path),
            #                             'logical_path': ('%s', lambda data: data['oss']['paths'][path]['lp'])
            #                         },
            #                         bits=[
            #                             ("", "%d",
            #                              lambda data: data['oss']['paths'][path]['free'] * 1024)
            #                         ],
            #                         typ='gauge',
            #                         hlp='available capacity')
            # msg += self.add_metrics(ks, 'xrootd_oss_paths_tot',
            #                         unit='bytes',
            #                         attrs={
            #                             'real_path': ('%s', path)
            #                         },
            #                         bits=[
            #                             ("", "%d",
            #                              lambda data: data['oss']['paths'][path]['tot'] * 1024)
            #                         ],
            #                         typ='gauge',
            #                         hlp='total capacity')
            # msg += self.add_metrics(ks, 'xrootd_oss_paths_ifr',
            #                         unit='bytes',
            #                         attrs={
            #                             'real_path': ('%s', path)
            #                         },
            #                         bits=[
            #                             ("", "%d",
            #                              lambda data: data['oss']['paths'][path]['ifr'])
            #                         ],
            #                         typ='gauge',
            #                         hlp='free inodes')
            # msg += self.add_metrics(ks, 'xrootd_oss_paths_ino',
            #                         unit='bytes',
            #                         attrs={
            #                             'real_path': ('%s', path)
            #                         },
            #                         bits=[
            #                             ("", "%d",
            #                              lambda data: data['oss']['paths'][path]['ino'])
            #                         ],
            #                         typ='gauge',
            #                         hlp='total inodes')

            msg += '# EOF\n'

            pass

        return (msg, latest)

    def check(self):
        with self.lock:
            return self.running
        pass

    def halt(self):
        with self.lock:
            self.running = False
            pass
        pass

    pass

class MetricsReceiver:
    def __init__(self, sock, hist):
        self.sock = sock
        self.hist = hist
        self.running = True
        pass

    def keep_polling(self):
        while self.hist.check():
            try:
                self.poll()
                pass
            except KeyboardInterrupt:
                break
            except:
                traceback.print_exc()
                pass
            continue
        pass

    def halt(self):
        try:
            self.sock.shutdown(socket.SHUT_RDWR)
        except OSError:
            pass
        self.sock.close()

    def poll(self):
        ## Receive XML in a UDP packet.
        try:
            (msg, addr) = self.sock.recvfrom(65536)
        except OSError:
            return
        try:
            tree = ElementTree.fromstring(msg)
        except xml.etree.ElementTree.ParseError:
            return
        print('\nFrom %s:%d:' % addr)
        if tree.tag != 'statistics':
            print('  not statistics')
            return

        ## Extract timestamp data.
        timestamp = int(tree.attrib['tod'])
        start = int(tree.attrib['tos'])

        ## Index all the <stats> elements by id.
        stats = { }
        for stat in tree.findall('stats'):
            kind = stat.attrib.get('id')
            if kind is None:
                continue
            stats[kind] = stat
            continue

        ## Get an instance identifier.
        blk = stats.get('info')
        if blk is None:
            print('  no info element')
            return
        host = blk.find('host').text
        name = blk.find('name').text
        inst = (host, name)
        print('  instance %s@%s' % (name, host))

        ## Extract the fields we're interested in.
        data = { }
        data['start'] = start

        blk = stats.get('buff')
        if blk is not None:
            sub = data.setdefault('buff', { })
            for key in [ 'reqs', 'mem', 'buffs', 'adj' ]:
                sub[key] = int(blk.find('./' + key).text)
                continue
            pass

        blk = stats.get('link')
        if blk is not None:
            sub = data.setdefault('link', { })
            for key in [ 'num', 'maxn', 'tot', 'in', 'out',
                         'ctime', 'tmo', 'stall', 'sfps' ]:
                sub[key] = int(blk.find('./' + key).text)
                continue
            pass
        blk = stats.get('poll')
        if blk is not None:
            sub = data.setdefault('poll', { })
            for key in [ 'att', 'ev', 'en', 'int' ]:
                sub[key] = int(blk.find('./' + key).text)
                continue
            pass

        blk = stats.get('sched')
        if blk is not None:
            sub = data.setdefault('sched', { })
            for key in [ 'jobs', 'inq', 'maxinq', 'threads',
                         'idle', 'tcr', 'tde', 'tlimr' ]:
                sub[key] = int(blk.find('./' + key).text)
                continue
            pass

        blk = stats.get('sgen')
        if blk is not None:
            sub = data.setdefault('sgen', { })
            for key in [ 'as', 'et', 'toe' ]:
                sub[key] = int(blk.find('./' + key).text)
                continue
            pass

        blk = stats.get('oss')
        if blk is not None:
            sub = data.setdefault('oss', { })
            for i in range(int(blk.find('./paths').text)):
                print('  Searching for path %d' % i)
                elem = blk.find('./paths/stats[@id="%d"]' % i)
                print(ElementTree.tostring(blk, encoding="unicode"))
                name = elem.find('./rp').text
                psub = sub.setdefault('paths', { }).setdefault(name, { })
                psub['lp'] = elem.find('./lp').text
                for key in [ 'free', 'ifr', 'ino', 'tot' ]:
                    psub[key] = int(elem.find('./' + key).text)
                continue
            for i in range(int(blk.find('./space').text)):
                print('  Searching for space %d' % i)
                elem = blk.find('./space/stats[@id="%d"]' % i)
                name = elem.find('./name').text
                psub = sub.setdefault('spaces', { }).setdefault(name, { })
                for key in [ 'free', 'fsn', 'maxf', 'qta', 'tot', 'usg' ]:
                    psub[key] = int(elem.find('./' + key).text)
                continue
            pass

        blk = stats.get('ofs')
        if blk is not None:
            sub = data.setdefault('ofs', { })
            for key in [ 'opr', 'opw', 'opp', 'ups', 'han', 'rdr',
                         'bxq', 'rep', 'err', 'dly', 'sok', 'ser' ]:
                sub[key] = int(blk.find('./' + key).text)
                continue
            sub['role'] = blk.find('./role').text
            psub = sub.setdefault('tpc', { })
            for key in [ 'grnt', 'deny', 'err', 'exp' ]:
                psub[key] = int(blk.find('./tpc/' + key).text)
                continue
            pass

        blk = stats.get('xrootd')
        if blk is not None:
            sub = data.setdefault('xrootd', { })
            for key in [ 'num', 'err', 'rdr', 'dly' ]:
                sub[key] = int(blk.find('./' + key).text)
                continue
            psub = sub.setdefault('ops', { })
            elem = blk.find('./ops')
            for key in [ 'open', 'rf', 'rd', 'pr', 'rv', 'rs', 'wv', 'ws',
                         'wr', 'sync', 'getf', 'putf', 'misc' ]:
                psub[key] = int(elem.find('./' + key).text)
                continue
            psub = sub.setdefault('sig', { })
            elem = blk.find('./sig')
            for key in [ 'ok', 'bad', 'ign' ]:
                psub[key] = int(elem.find('./' + key).text)
                continue
            psub = sub.setdefault('aio', { })
            elem = blk.find('./aio')
            for key in [ 'num', 'max', 'rej' ]:
                psub[key] = int(elem.find('./' + key).text)
                continue
            psub = sub.setdefault('lgn', { })
            elem = blk.find('./lgn')
            for key in [ 'num', 'af', 'au', 'ua' ]:
                psub[key] = int(elem.find('./' + key).text)
                continue
            pass

        blk = stats.get('proc')
        if blk is not None:
            sub = data.setdefault('proc', { })
            sub['sys'] = int(blk.find('./sys/s').text) \
                + int(blk.find('./sys/u').text) / 1000000.0
            sub['usr'] = int(blk.find('./usr/s').text) \
                + int(blk.find('./usr/u').text) / 1000000.0
            pass

        ## Get the entry we want to populate, indexed by timestamp and
        ## by (host, name).
        self.hist.install(timestamp, inst, data)
        return

    pass

class MetricsSender(BaseHTTPRequestHandler):
    def __init__(self, *args, hist=None, last_calls=None, **kwargs):
        self.hist = hist
        self.last_calls = last_calls
        super().__init__(*args, **kwargs)
        pass

    def do_GET(self):
        ## Identify the client by the authorization string.
        auth = self.headers.get('Authorization')
        if auth is None:
            auth = 'anonymous'
            pass

        ## Find out what time range the client is asking for.  We
        ## simply record the last time they called, and assume it was
        ## successful.
        lastTime = self.last_calls.setdefault(auth, 0)
        #print('Supplying client %s since %d' % (auth, lastTime))

        ## Form the message body.
        body, currTime = self.hist.get_message(lastTime)
        print('Client %s: %d-%d' % (auth, lastTime, currTime))
        self.last_calls[auth] = currTime

        ## Transmit the response.
        self.send_response(200)
        ct = 'application/openmetrics-text'
        ct += '; version=1.0.0; charset=utf-8'
        self.send_header('Content-Type', ct)
        self.end_headers()
        self.wfile.write(body.encode('UTF-8'))
        pass
    pass

udp_host = ''
udp_port = 9485
http_host = 'localhost'
http_port = 8744

## Record XRootD stats history, indexed by timestamp and instance.
history = XRootDHistory(horizon = 60 * 30)

## Create a datagram Internet socket, and bind to INADDR_ANY and a
## specific port.  TODO: Hide this in the metrics receiver class,
metrics_in = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
metrics_in.bind((udp_host, udp_port))

receiver = MetricsReceiver(metrics_in, history)

## Run receiver.keep_polling() as a separate thread.
recv_thrd = threading.Thread(target=MetricsReceiver.keep_polling,
                             args=(receiver,))
recv_thrd.start()

print('Creating HTTP server...')
## TODO: last_calls might need to be thread-safe...?
last_calls = { }
partial_handler = functools.partial(MetricsSender, hist=history,
                                    last_calls=last_calls)
webserver = HTTPServer((http_host, http_port), partial_handler)
print('Started on http://%s:%s' % (http_host, http_port))

try:
    webserver.serve_forever()
except KeyboardInterrupt:
    pass

history.halt()
print('Halted history')
receiver.halt()
print('Halted receiver')
recv_thrd.join()
print('Receiver thread joined')

webserver.server_close()
print('Server stopped.')
