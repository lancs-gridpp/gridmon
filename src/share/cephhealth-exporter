#!/bin/env python3

## Copyright (c) 2022, Lancaster University
## All rights reserved.
##
## Redistribution and use in source and binary forms, with or without
## modification, are permitted provided that the following conditions
## are met:
##
## 1. Redistributions of source code must retain the above copyright
##    notice, this list of conditions and the following disclaimer.
##
## 2. Redistributions in binary form must reproduce the above
##    copyright notice, this list of conditions and the following
##    disclaimer in the documentation and/or other materials provided
##    with the distribution.
##
## 3. Neither the name of the copyright holder nor the names of its
##    contributors may be used to endorse or promote products derived
##    from this software without specific prior written permission.
##
## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
## "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
## LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
## FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
## COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
## SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
## HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
## STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
## OF THE POSSIBILITY OF SUCH DAMAGE.

import functools
from http.server import HTTPServer
import threading
import pprint
import subprocess
import sys
import time
import json
import re
from getopt import gnu_getopt
import logging
import traceback
import datetime

## Local libraries
import cephhealth
import metrics

todfmt = re.compile(r'([0-9]{1,2}):([0-9]{1,2})')
def get_tod_offset(text):
    m = todfmt.match(text)
    if m is None:
        return None
    hrt, mnt = m.groups()
    hr = int(hrt)
    mn = int(mnt)
    if hr < 0 or hr > 23:
        return None
    if mn < 0 or mn > 59:
        return None
    return (hr * 60 + mn) * 60

http_host = "localhost"
http_port = 8799
horizon = 60 * 60 * 24 * 3
lag = 20
disk_limit = None
log_params = {
    'format': '%(asctime)s %(message)s',
    'datefmt': '%Y-%d-%mT%H:%M:%S',
}
schedule = set()
opts, args = gnu_getopt(sys.argv[1:], "h:l:T:t:s:",
                        [ 'disk-limit=', 'log=', 'log-file=' ])
for opt, val in opts:
    if opt == '-h':
        horizon = int(val) * 60 * 60 * 24
    elif opt == '-l':
        lag = int(val)
    elif opt == '-s':
        tod = get_tod_offset(val)
        if tod is None:
            sys.stderr.write('bad time of day: %s' % val)
            sys.exit(1)
            pass
        schedule.add(tod)
    elif opt == '-T':
        http_host = val
    elif opt == '-t':
        http_port = int(val)
    elif opt == '--log':
        log_params['level'] = getattr(logging, val.upper(), None)
        if not isinstance(log_params['level'], int):
            sys.stderr.write('bad log level [%s]\n' % val)
            sys.exit(1)
            pass
        pass
    elif opt == '--log-file':
        log_params['filename'] = val
    elif opt == '--disk-limit':
        disk_limit = int(val)
        pass
    continue

## If no schedule is provided, define the current time of day as the
## sole entry.
if len(schedule) == 0:
    now = datetime.datetime.utcnow()
    tod = (now.hour * 60 + now.minute) * 60
    schedule.add(tod)
    pass

logging.basicConfig(**log_params)
logging.info('Schedule: %s' % [
    '%02d:%02d:%02d' % (int(x / 3600),
                        int(x / 60) % 60,
                        x % 60) for x in schedule ])

def get_next_in_schedule(schedule):
    ## What time is it now?  When did this day start?  When does
    ## tomorrow start?
    calnow = datetime.datetime.now(tz=datetime.timezone.utc)
    caltoday = datetime.datetime(calnow.year, calnow.month, calnow.day,
                              tzinfo=datetime.timezone.utc)
    tod = (calnow - caltoday).total_seconds()
    caltomorrow = caltoday + datetime.timedelta(days=1)
    tomorrow = datetime.datetime.timestamp(caltomorrow)
    today = datetime.datetime.timestamp(caltoday)

    ## Try each time of day in the schedule, to see whether it is next
    ## today or tomorrow.
    best = None
    for scand in schedule:
        cand = scand + (tomorrow if scand < tod else today)
        if best is None or cand < best:
            best = cand
        continue
    return best

cephcoll = cephhealth.CephHealthCollector(args, lag=lag, horizon=horizon)
methist = metrics.MetricHistory(cephhealth.schema, horizon=horizon)
nowmets = functools.partial(cephhealth.get_osd_complaints_as_metrics, args=args)
partial_handler = functools.partial(metrics.MetricsHTTPHandler,
                                    hist=methist,
                                    prebody=nowmets)
webserver = HTTPServer((http_host, http_port), partial_handler)

def check_delay(hist, start):
    if not hist.check():
        return False
    now = int(time.time())
    delay = start - now
    return delay > 0

def keep_polling(hist, coll, schedule):
    global disk_limit
    try:
        while hist.check():
            logging.info('Getting latest data')
            new_data = coll.update(limit=disk_limit)
            hist.install(new_data)
            logging.info('Installed')
            start = get_next_in_schedule(schedule)
            lim = datetime.datetime.fromtimestamp(start)
            logging.info('Waiting until %s in %s' % \
                         (lim, datetime.timedelta(seconds=start - time.time())))
            while check_delay(hist, start):
                time.sleep(1)
                pass
            continue
    except InterruptedError:
        pass
    except KeyboardInterrupt:
        pass
    except Exception as e:
        logging.error(traceback.format_exc())
        pass
    logging.info('Polling halted')
    hist.halt()
    pass

poll_thrd = threading.Thread(target=keep_polling,
                             args=(methist, cephcoll, schedule))
poll_thrd.start()

try:
    webserver.serve_forever()
except KeyboardInterrupt:
    pass
logging.info('HTTP halted')

methist.halt()
sys.exit(0)

# result = { }
# cephhealth.get_device_metrics(result, "TOSHIBA_MG08SCA16TEY_11X0A1Z2F9SH",
#                               args=args,
#                               start=1665794097,
#                               adorn={'a': 30})
# pprint.pprint(result)
# sys.exit(0)

# pprint.pprint(cephhealth.get_device_set(args))
# sys.exit(0)

# pprint.pprint(cephcoll.update(limit=2))
# sys.exit(0)

data = cephcoll.update(limit=1)
methist.install(data, mismatch=-1)

# now = int(time.time())
# sample = {
#     now - 20: {
#         'TOSHIBA_MG08SCA16TEY_11X0A1Z2F9SH': {
#             'defects': 2000,
#             'uncorrected': {
#                 'read': 104,
#                 'write': 1,
#                 'verify': 0,
#             },
#         },
#     },
# }


# sample = {
#     1666052642: {
#         'TOSHIBA_MG08SCA16TEY_11P0A00NF9SH': {
#             'defects': 0,
#             'host': 'stor057',
#             'path': 'pci-0000:18:00.0-scsi-0:0:16:0',
#             'uncorrected': {
#                 'read': 0,
#                 'verify': 0,
#                 'write': 0
#             }
#         }
#     },
#     1666139254: {
#         'TOSHIBA_MG08SCA16TEY_11P0A00NF9SH': {
#             'defects': 0,
#             'host': 'stor057',
#             'path': 'pci-0000:18:00.0-scsi-0:0:16:0',
#             'uncorrected': {
#                 'read': 0,
#                 'verify': 0,
#                 'write': 0
#             }
#         }
#     }
# }
# methist.install(sample)

body, ts0, ts1 = methist.get_message('foo')
sys.stdout.write(body)
